:imagesdir: images
:last-update-label!:
:stem:

= Atividades da Unidade II =
by Pablio Martins

== Atividade 01 ==

== Atividade 02 ==

*Enunciado:* +
Utilizando o programa *dftfilter.cpp* como referência, implemente o filtro homomórfico para melhorar imagens com iluminação irregular. Crie uma cena mal iluminada e ajuste os parâmetros do filtro homomórfico para corrigir a iluminação da melhor forma possível. Assuma que a imagem fornecida é em tons de cinza.

A filtragem homomórfica baseia-se em princípios de iluminância e reflectância para realizar a filtragem. Dado os pixels de uma imagem podem ser expressos em:

[stem]
++++
f(x,y) = i(x,y)r(x,y)
++++

Em que temos a componente de iluminação (*i*) e reflectância (*r*).

Considerando todas os tratamentos necessários, podemos construir o filtro com base na seguinte equação:

[stem]
++++
H(u,v) = (\gamma H - \gamma L) \left( 1 - \e^{-C \left( \frac{D^{2}(u,v)}{D_{0}^{2}} \right)} + \right) + \gamma L
++++

Esse filtro deve atenuar as frequências mais baixas e manter as frequências mais altas.

Abaixo segue o código implementado:

.Show Code
[%collapsible]
====
[source, cpp]
.dftfilter.cpp
----
include::codes/dftfilter.cpp[]
----
====

Resultados:
[.float-group]
--
[.left]
.Imagem em tons de cinza
image::homo_gray.png[A, 350]

[.left]
.Filtro com parametros gammaL: 2.5, gammaH: 0.6, C: 0.3, D0: 12
image::HomomorphicFilter.png[B, 350]

[.left]
.Imagem com a aplicação do filtro
image::dftImagefilter.png[C, 350]
--

====
Comentários:

A função homomorphicFilter é responsável pela geração da matriz 2d do filtro.
[source, cpp]
----
void homomorphicFilter(cv::Mat &image, cv::Mat &filter){
  cv::Mat filter2D = cv::Mat(image.rows, image.cols, CV_32F);
  int centerX = image.rows / 2;
  int centerY = image.cols / 2;

  for(int i=0; i<image.rows; i++){
    for(int j=0; j<image.cols; j++){
      filter2D.at<float> (i, j) = (gammaH - gammaL)*(
          1 - exp(-C*(( pow(i - centerX, 2) + pow(j - centerY, 2)) / pow(D0, 2)))
        ) + gammaL;
    }
  }
  cv::Mat planes[] = {filter2D, cv::Mat::zeros(filter2D.size(), CV_32F)};
  cv::merge(planes, 2, filter);

  cv::normalize(filter2D, filter2D, 0, 255, cv::NORM_MINMAX);
  filter2D.convertTo(filter2D, CV_8U);
  cv::imwrite("./img/HomomorphicFilter.png", filter2D);
}
----

O laço *for* percorre toda a matriz da imagem ponderando as posições com valores entre 0 e 1. O cálculo é feito usando a equação descrita em momento anterior.
====

== Atividade 03 == 

== Atividade 04 ==

== Atividade 05 ==

Projetar um código que deixe os números expressos em segmentos de forma continua, usando técnicas de morfologia.

segue as imagens exemplos:
[.float-group]
--
[.left]
image::digitos-1.png[A, 250]

[.left]
image::digitos-2.png[B, 250]

[.left]
image::digitos-3.png[C, 250]

[.left]
image::digitos-4.png[D, 250]

[.left]
image::digitos-5.png[E, 250]
--

segue o código implementado:

.Show Code
[%collapsible]
====
[source, cpp]
.dftfilter.cpp
----
include::codes/morfologia.cpp[]
----
====

Resultados:
[.float-group]
--
[.left]
image::digitos_1_morf.png[A, 250]

[.left]
image::digitos_2_morf.png[B, 250]

[.left]
image::digitos_3_morf.png[C, 250]

[.left]
image::digitos_4_morf.png[D, 250]

[.left]
image::digitos_5_morf.png[E, 250]
--

====
Comentários:

[source, cpp]
----
str_v = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(1,15));
str_h = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3,1));
----

[source, cpp]
----
cv::erode(image_in, image_out, str_v);
cv::erode(image_out, image_out, str_h);
cv::dilate(image_out, image_out, str_v);
----

====