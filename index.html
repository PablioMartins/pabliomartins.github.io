<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="generator" content="Asciidoctor 2.0.10"/>
<meta name="author" content="by Pablio Martins"/>
<title>Atividades da Unidade I</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"/>
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Atividades da Unidade I</h1>
<div class="details">
<span id="author" class="author">by Pablio Martins</span><br/>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_atividade_01">Atividade 01</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_etapa_01"><strong>Etapa 01</strong></h3>
<div class="paragraph">
<p>Esta primeira atividade deverá solicitar do usuário dois pontos, localizados dentro dos limites do tamanho de uma imagem, e exibir o negativo da imagem no interior do retangulo formado por esses dois pontos.</p>
</div>
<div class="paragraph">
<p>O código esctrito na linguagem C++ pode ser visto a seguir clicando em <strong>Show Code</strong>:</p>
</div>
<details>
<summary class="title">Show Code</summary>
<div class="content">
<div class="listingblock">
<div class="title">regions.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

int main(int, char**){
    cv::Mat image;
    cv::Vec3b val;

    image = cv::imread("./img/biel.png", cv::IMREAD_GRAYSCALE);
    if(!image.data){
        std::cout &lt;&lt; "Nao foi possivel abrir a imagem" &lt;&lt; std::endl;
        return 0;
    }

    cv::Vec2i first_point;
    cv::Vec2i second_point;

    do{
        std::cout &lt;&lt; "Digite a coordenada 'x' do primero ponto (0 a " &lt;&lt;  image.rows &lt;&lt; ")" &lt;&lt; std::endl;
        std::cin &gt;&gt; first_point[0];
        if(first_point[0] &lt; 0 || first_point[0] &gt;= image.rows)
            std::cout &lt;&lt; "O valor deve ser entre 0 e " &lt;&lt; image.rows &lt;&lt; std::endl;
    } while (first_point[0] &lt; 0 || first_point[0] &gt;= image.rows);

    do{
        std::cout &lt;&lt; "Digite a coordenada 'y' do primero ponto (0 a " &lt;&lt;  image.cols &lt;&lt; ")" &lt;&lt; std::endl;
        std::cin &gt;&gt; first_point[1];
        if(first_point[1] &lt; 0 || first_point[1] &gt;= image.cols)
            std::cout &lt;&lt; "O valor deve ser entre 0 e " &lt;&lt; image.cols &lt;&lt; std::endl;
    } while (first_point[1] &lt; 0 || first_point[1] &gt;= image.cols);

    do{
        std::cout &lt;&lt; "Digite a coordenada 'x' do segundo ponto (0 a " &lt;&lt;  image.rows &lt;&lt; ")" &lt;&lt; std::endl;
        std::cin &gt;&gt; second_point[0];
        if(second_point[0] &lt; 0 || second_point[0] &gt;= image.rows)
            std::cout &lt;&lt; "O valor deve ser entre 0 e " &lt;&lt; image.rows &lt;&lt; std::endl;
    } while (second_point[0] &lt; 0 || second_point[0] &gt;= image.rows);

    do{
        std::cout &lt;&lt; "Digite a coordenada 'y' do primero ponto (0 a " &lt;&lt;  image.cols &lt;&lt; ")" &lt;&lt; std::endl;
        std::cin &gt;&gt; second_point[1];
        if(second_point[1] &lt; 0 || second_point[1] &gt;= image.cols)
            std::cout &lt;&lt; "O valor deve ser entre 0 e " &lt;&lt; image.cols &lt;&lt; std::endl;
    } while (second_point[1] &lt; 0 || second_point[1] &gt;= image.cols);

    int x_smaller, x_bigger, y_smaller, y_bigger;
    if(first_point[0] &lt; second_point[0]){
        x_smaller = first_point[0];
        x_bigger = second_point[0];
    }
    else {
        x_smaller = second_point[0];
        x_bigger = first_point[0];
    }

    if(first_point[1] &lt; second_point[1]){
        y_smaller = first_point[1];
        y_bigger = second_point[1];
    }
    else {
        y_smaller = second_point[1];
        y_bigger = first_point[1];
    }

    for( int i = x_smaller; i &lt; x_bigger; i++){
        for(int j = y_smaller; j &lt; y_bigger; j++){
            image.at&lt;uchar&gt;(i,j) = 255 - image.at&lt;uchar&gt;(i,j);
        }
    }

    cv::imshow("Regions", image);
    cv::imwrite("./resultimg/regions.png", image);
    cv::waitKey();
    return 0;
}</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>O resultado é:</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/biel.png" alt="A" width="240"/>
</div>
<div class="title">Figure 1. Imagem Original</div>
</div>
<div class="imageblock left">
<div class="content">
<img src="images/regions.png" alt="B" width="240"/>
</div>
<div class="title">Figure 2. Imagem Com Negativo</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Comentários:</p>
</div>
<div class="paragraph">
<p>A linha a seguir é responsável pela leitura da imagem em tons de cinza, evidenciado pelo parametro <strong>IMREAD_GRAYSCALE</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">image = cv::imread("./img/biel.png", cv::IMREAD_GRAYSCALE);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Seguindo no código temos a declaração de:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">cv::Vec2i first_point;
cv::Vec2i second_point;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Que são vetores com duas posições do tipo inteiro que armazenarão os pontos fornecidos pelo usuário.</p>
</div>
<div class="paragraph">
<p>Uma estrutura semelhate a:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">do{
        std::cout &lt;&lt; "Digite a coordenada 'x' do primero ponto (0 a " &lt;&lt;  image.rows &lt;&lt; ")" &lt;&lt; std::endl;
        std::cin &gt;&gt; first_point[0];
        if(first_point[0] &lt; 0 || first_point[0] &gt;= image.rows)
            std::cout &lt;&lt; "O valor deve ser entre 0 e " &lt;&lt; image.rows &lt;&lt; std::endl;
} while (first_point[0] &lt; 0 || first_point[0] &gt;= image.rows);</code></pre>
</div>
</div>
<div class="paragraph">
<p>é feita para cada coordenada dos pontos fornecidos pelo usuário, afim de garantir que o ponto estará dentro dos limites da imagem.</p>
</div>
<div class="paragraph">
<p>A estrutura de código seguinte é responsável por garantir que a posição da coordenadas <strong>x</strong> do <strong>ponto 1</strong> seja menor que a posição da coordenada <strong>x</strong> do <strong>ponto 2</strong>, o mesmo artifício é aplicado na coodenanda <strong>y</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">if(first_point[0] &lt; second_point[0]){
    x_smaller = first_point[0];
    x_bigger = second_point[0];
}
else {
    x_smaller = second_point[0];
    x_bigger = first_point[0];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nesta próxima etapa do codigo, é feita uma varredura por todo bloco retangular obitido dos dois pontos fornecido, troca-se o pixel atual por seu valor inverso. O valor inverso é dado pela subtração do valor máximo da representação da cor (255) com o valor atual do pixel.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">for( int i = x_smaller; i &lt; x_bigger; i++){
    for(int j = y_smaller; j &lt; y_bigger; j++){
        image.at&lt;uchar&gt;(i,j) = 255 - image.at&lt;uchar&gt;(i,j);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_etapa_02">Etapa 02</h3>
<div class="paragraph">
<p>Nesta Segunda etapa da <strong>atividade 01</strong> o programa deverá trocar os quadrantes da diagonal na imagem.</p>
</div>
<div class="paragraph">
<p>Nesse sentido, o código implementado pode ser vista abaixo:</p>
</div>
<details>
<summary class="title">Show Code</summary>
<div class="content">
<div class="listingblock">
<div class="title">replaceregions.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

int main(int, char**){
    cv::Mat image;

    image = cv::imread("./img/biel.png", cv::IMREAD_GRAYSCALE);
    if(!image.data){
        std::cout &lt;&lt; "Nao foi possivel abrir a imagem" &lt;&lt; std::endl;
        return 0;
    }

    int image_height = image.rows;
    int image_width = image.cols;

    cv::Mat image_result;
    image_result = cv::Mat::zeros(image_height, image_width, CV_8UC1);

    image(cv::Rect(0,0,image_width/2, image_height/2)).copyTo(image_result(cv::Rect(image_width/2, image_height/2,image_width/2, image_height/2)));
    image(cv::Rect(image_width/2, image_height/2,image_width/2, image_height/2)).copyTo(image_result(cv::Rect(0, 0,image_width/2, image_height/2)));
    image(cv::Rect(image_width/2, 0,image_width/2, image_height/2)).copyTo(image_result(cv::Rect(0, image_width/2,image_width/2, image_height/2)));
    image(cv::Rect(0, image_height/2,image_width/2, image_height/2)).copyTo(image_result(cv::Rect(image_width/2, 0,image_width/2, image_height/2)));

    cv::imshow("ReplaceRegions", image_result);
    cv::imwrite("./resultimg/repleaceregions.png", image_result);
    cv::waitKey();

    return 0;
}</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>Os resultados são:</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/biel.png" alt="A" width="240"/>
</div>
<div class="title">Figure 3. Imagem Original</div>
</div>
<div class="imageblock left">
<div class="content">
<img src="images/repleaceregions.png" alt="B" width="240"/>
</div>
<div class="title">Figure 4. Imagem diagonais trocadas</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Comentário:</p>
</div>
<div class="paragraph">
<p>O trecho de código abaixo inicializa uma matriz com as proporções da imagem original, em que todas as posições da matriz são preenchidas com zero. Nota-se também que a matriz criada é <strong>unsigned char de 8 bits</strong> e com apenas um canal, conforme mostra o parametro <strong>CV_8UC1</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">image_result = cv::Mat::zeros(image_height, image_width, CV_8UC1);</code></pre>
</div>
</div>
<div class="paragraph">
<p>O próximo bloco de código realiza a troca dos quadrantes da imagem. Com o centro posicionado no meio da figura o método <strong>Rect</strong> copia quadros para a variável <strong>image_result</strong> posisionando-os nos quadrantes de forma a produzir a inversão.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">image(cv::Rect(0,0,image_width/2,image_height/2))
    .copyTo(image_result(cv::Rect(image_width/2, image_height/2,image_width/2, image_height/2)));
image(cv::Rect(image_width/2, image_height/2,image_width/2, image_height/2))
    .copyTo(image_result(cv::Rect(0, 0,image_width/2, image_height/2)));
image(cv::Rect(image_width/2, 0,image_width/2, image_height/2))
    .copyTo(image_result(cv::Rect(0, image_width/2,image_width/2, image_height/2)));
image(cv::Rect(0, image_height/2,image_width/2, image_height/2))
    .copyTo(image_result(cv::Rect(image_width/2, 0,image_width/2, image_height/2)));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_atividade_02">Atividade 02</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A segunda atividade consiste em criar uma imagem com dimensões 256x256 pixels contendo uma senóide de 4 períodos e com amplitude de 127 desenhada na horizonal. A imagem gerada deve ser salva em PNG e em YML. Um gráfico deve ser gerado mostrando a diferença entre uma imagem e a outra ao percorrer uma linha da matriz de cada imagem.</p>
</div>
<details>
<summary class="title">Show Code</summary>
<div class="content">
<div class="listingblock">
<div class="title">filestorage.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int SIDE = 256;
int PERIODOS = 4;

int main(int argc, char** argv) {
  std::stringstream ss_img, ss_yml;
  cv::Mat image;

  ss_yml &lt;&lt; "./resultimg/senoide-" &lt;&lt; SIDE &lt;&lt; ".yml";
  image = cv::Mat::zeros(SIDE, SIDE, CV_32FC1);

  cv::FileStorage fs(ss_yml.str(), cv::FileStorage::WRITE);

  for (int i = 0; i &lt; SIDE; i++) {
    for (int j = 0; j &lt; SIDE; j++) {
      image.at&lt;float&gt;(i, j) = 127 * sin(2 * M_PI * PERIODOS * j / SIDE) + 128;
    }
  }

  fs &lt;&lt; "mat" &lt;&lt; image;
  fs.release();

  cv::normalize(image, image, 0, 255, cv::NORM_MINMAX);
  image.convertTo(image, CV_8U);
  ss_img &lt;&lt; "./resultimg/senoide-" &lt;&lt; SIDE &lt;&lt; ".png";
  cv::imwrite(ss_img.str(), image);

  fs.open(ss_yml.str(), cv::FileStorage::READ);
  fs["mat"] &gt;&gt; image;

  cv::normalize(image, image, 0, 255, cv::NORM_MINMAX);
  image.convertTo(image, CV_8U);

  cv::imshow("image", image);
  cv::waitKey();

  return 0;
}</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>O resultado é:</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/senoide-256.png" alt="A" width="240"/>
</div>
<div class="title">Figure 5. Imagem gerada (PNG)</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Comentários:</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_atividade_03">Atividade 03</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esta Atividade propõe a recuperação de uma imagem codificada de uma imagem resultante. Os bits menos significantes de uma imagem são subistituídos por bits mais significantes de outra imagem, fazendo assim com que uma imagem fique oculta em outra.</p>
</div>
<details>
<summary class="title">Show Code</summary>
<div class="content">
<div class="listingblock">
<div class="title">esteg-encode.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

int main(int argc, char**argv) {
    cv::Mat imagemEscondida, imagemCodificada;
    cv::Vec3b valEscondida, valCodificada;

    imagemCodificada = cv::imread(argv[1], cv::IMREAD_COLOR);

    if (imagemCodificada.empty()) {
        std::cout &lt;&lt; "imagem nao carregou corretamente" &lt;&lt; std::endl;
        return (-1);
    }

    imagemEscondida = cv::Mat::zeros(imagemCodificada.rows, imagemCodificada.cols, CV_8UC3);

    for (int i = 0; i &lt; imagemCodificada.rows; i++) {
        for (int j = 0; j &lt; imagemCodificada.cols; j++) {
            valCodificada = imagemCodificada.at&lt;cv::Vec3b&gt;(i, j);
            valEscondida[0] = (0b00000111 &amp; valCodificada[0]) &lt;&lt; 5;
            valEscondida[1] = (0b00000111 &amp; valCodificada[1]) &lt;&lt; 5;
            valEscondida[2] = (0b00000111 &amp; valCodificada[2]) &lt;&lt; 5;
            imagemEscondida.at&lt;cv::Vec3b&gt;(i, j) = valEscondida;
        }
    }
    imwrite("./resultimg/esteganografia.png", imagemEscondida);
    return 0;
}</code></pre>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>O resultado é:</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/desafio-esteganografia.png" alt="A" width="240"/>
</div>
<div class="title">Figure 6. Imagem Codificada</div>
</div>
<div class="imageblock left">
<div class="content">
<img src="images/esteganografia.png" alt="B" width="240"/>
</div>
<div class="title">Figure 7. Imagem Descodificada</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Comentário:</p>
</div>
<div class="paragraph">
<p>O trecho exposto logo abaixo faz a inicialização de uma matriz de três canais com valores zerados nas dimensões da imagem original. Essa matriz irá armazenar os bits menos significativos da imagem original, e revelar qual a imagem está escondida.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">imagemEscondida = cv::Mat::zeros(imagemCodificada.rows, imagemCodificada.cols, CV_8UC3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>No trecho seguinte é feito uma varredura por toda a matriz da imagem original, é coletando apenas os <strong>3 bits</strong> menos significativos e efetuando um deslocamento de <strong>5 bits a direita</strong> para posicioná-los nas posições significativas da representação binária. Assim, é possível exibir a imagem escondida.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">for (int i = 0; i &lt; imagemCodificada.rows; i++) {
    for (int j = 0; j &lt; imagemCodificada.cols; j++) {
        valCodificada = imagemCodificada.at&lt;cv::Vec3b&gt;(i, j);
        valEscondida[0] = (0b00000111 &amp; valCodificada[0]) &lt;&lt; 5;
        valEscondida[1] = (0b00000111 &amp; valCodificada[1]) &lt;&lt; 5;
        valEscondida[2] = (0b00000111 &amp; valCodificada[2]) &lt;&lt; 5;
        imagemEscondida.at&lt;cv::Vec3b&gt;(i, j) = valEscondida;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_atividade_04">Atividade 04</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_etapa_01_2">Etapa 01</h3>
<div class="paragraph">
<p>Nesta Atividade propõe-se que seja discutido a rotulação com tons de objetos em uma cena. Nos casos em que a rotulação ocorre em imagens com menos de 255 objetos em uma cena, a escala de cinza se mostra uma forte aliada, mas e para imagens que extrapolam esse valor?<br/>
Para resolver esse problema poderiamos adicionar componentes de cor, por exemplo o sistema RGB, assim haveria <strong>255x255x255</strong> possibilidades de marcação dos objetos em cena.</p>
</div>
</div>
<div class="sect2">
<h3 id="_etapa_02_2">Etapa 02</h3>
<div class="paragraph">
<p>A segunda etapa consiste em codificar um identificador de regiões com ou sem buracos internos que existam em uma cena. abaixo está a cena em estudo.</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/bolhas.png" alt="A" width="240"/>
</div>
<div class="title">Figure 8. Bolhas</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As regiões que tocam as bordas devem ser desconsideradas.</p>
</div>
<details>
<summary class="title">Show Code</summary>
<div class="content">
<div class="listingblock">
<div class="title">labeling.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

int main(int argc, char** argv){
    cv::Mat image;
    int width, height;
    int numberObjects, bubbles, donut;

    cv::Point pointWhite;

    image = cv::imread(argv[1], cv::IMREAD_GRAYSCALE);

    if(!image.data) {
        std::cout &lt;&lt; "Imagem nao foi carregada corretamente\n";
        return -1;
    }

    width = image.cols;
    height = image.rows;

    std::cout &lt;&lt; width &lt;&lt; "x" &lt;&lt; height &lt;&lt; std::endl;

    pointWhite.x = 0;
    pointWhite.y = 0;

    for(int i = 0; i &lt; height; i++){
        if(image.at&lt;uchar&gt;(i,0) == 255){
            pointWhite.x = 0;
            pointWhite.y = i;
            cv::floodFill(image, pointWhite, 0);
        }
        if(image.at&lt;uchar&gt;(i, height-1) == 255){
            pointWhite.x = height-1;
            pointWhite.y = i;
            cv::floodFill(image, pointWhite, 0);
        }
    }

    for(int i = 0; i &lt; width; i++){
        if(image.at&lt;uchar&gt;(0,i) == 255){
            pointWhite.x = i;
            pointWhite.y = 0;
            cv::floodFill(image, pointWhite, 0);
        }
        if(image.at&lt;uchar&gt;(width-1, i) == 255){
            pointWhite.x = i;
            pointWhite.y = width-1;
            cv::floodFill(image, pointWhite, 0);
        }
    }

    cv::imwrite("./resultimg/labeling_borda.png", image);

    numberObjects = 0;
    for(int i = 0; i &lt; height; i++){
        for(int j = 0; j &lt; width; j++){
            if(image.at&lt;uchar&gt;(i, j) == 255){
                numberObjects++;
                pointWhite.x = j;
                pointWhite.y = i;
                cv::floodFill(image, pointWhite, numberObjects);
            }
        }
    }
    cv::imwrite("./resultimg/labeling.png", image);

    cv::floodFill(image, cv::Point(0,0), 255);

    cv::imwrite("./resultimg/labeling_fundo.png", image);

    donut = 0;
    for(int i = 0; i &lt; height; i++){
        for(int j = 1; j &lt; width; j++){
            if(image.at&lt;uchar&gt;(i, j) == 0){
                if(image.at&lt;uchar&gt;(i,j-1) != 255){
                    donut++;
                    cv::floodFill(image, cv::Point(j,i), 255);
                    cv::floodFill(image, cv::Point(j-1,i), 255);
                }
                else{
                    cv::floodFill(image, cv::Point(j,i), 255);
                }
            }
        }
    }
    cv::imwrite("./resultimg/labeling_no_donut.png", image);

    bubbles = 0;
    for(int i = 0; i &lt; height; i++){
        for(int j = 0; j &lt; width; j++){
            if(image.at&lt;uchar&gt;(i, j) != 255){
                bubbles++;
                cv::floodFill(image, cv::Point(j,i), 255);
            }
        }
    }

    std::cout &lt;&lt; "Total de Objetos: " &lt;&lt; numberObjects &lt;&lt; std::endl;
    std::cout &lt;&lt; "Total de Rosquinha: " &lt;&lt; donut &lt;&lt; std::endl;
    std::cout &lt;&lt; "Total de Bolhas: " &lt;&lt; bubbles &lt;&lt; std::endl;

    cv::waitKey();
    return 0;
}</code></pre>
</div>
</div>
</div>
</details>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Comentários:</p>
</div>
<div class="paragraph">
<p>Para realizar a remoção dos objetos que tocam as bordas, foi executado uma varredura nas bordas da figura a procura de pixels brancos. O trecho abaixo mostra as instruções realizadas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">for(int i = 0; i &lt; height; i++){
    if(image.at&lt;uchar&gt;(i,0) == 255){
        pointWhite.x = 0;
        pointWhite.y = i;
        cv::floodFill(image, pointWhite, 0);
    }
    if(image.at&lt;uchar&gt;(i, height-1) == 255){
        pointWhite.x = height-1;
        pointWhite.y = i;
        cv::floodFill(image, pointWhite, 0);
    }
}

for(int i = 0; i &lt; width; i++){
    if(image.at&lt;uchar&gt;(0,i) == 255){
        pointWhite.x = i;
        pointWhite.y = 0;
        cv::floodFill(image, pointWhite, 0);
    }
    if(image.at&lt;uchar&gt;(width-1, i) == 255){
        pointWhite.x = i;
        pointWhite.y = width-1;
        cv::floodFill(image, pointWhite, 0);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como resultado temos:</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/labeling_borda.png" alt="A" width="240"/>
</div>
<div class="title">Figure 9. Bolhas sem elementos nas bordas</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Em seguida faz-se a contagem de elementos dentro da cena, usando diferentes tons de cinza para marcar os elementos ja computados. O trecho abaixo mostra as instruções executadas para essa tarefa.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">numberObjects = 0;
for(int i = 0; i &lt; height; i++){
    for(int j = 0; j &lt; width; j++){
        if(image.at&lt;uchar&gt;(i, j) == 255){
            numberObjects++;
            pointWhite.x = j;
            pointWhite.y = i;
            cv::floodFill(image, pointWhite, numberObjects);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como resultado temos:</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/labeling.png" alt="A" width="240"/>
</div>
<div class="title">Figure 10. Bolhas com rotulação</div>
</div>
</div>
</div>
<div class="paragraph">
<p>O próximo passo é tornar todo o fundo branco.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">cv::floodFill(image, cv::Point(0,0), 255);</code></pre>
</div>
</div>
<div class="paragraph">
<p>O resultado apresentado é:</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/labeling_fundo.png" alt="A" width="240"/>
</div>
<div class="title">Figure 11. Bolhas com rotulação</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Agora vamos identificar, contar e remover as bolhas que tenham 1 ou mais buracos. O trecho seguinte é responsável por essa tarefa.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">donut = 0;
for(int i = 0; i &lt; height; i++){
    for(int j = 1; j &lt; width; j++){
        if(image.at&lt;uchar&gt;(i, j) == 0){
            if(image.at&lt;uchar&gt;(i,j-1) != 255){
                donut++;
                cv::floodFill(image, cv::Point(j,i), 255);
                cv::floodFill(image, cv::Point(j-1,i), 255);
            }
            else{
                cv::floodFill(image, cv::Point(j,i), 255);
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Feito o passo anterior restam apenas as regiões que não contêm buracos.</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/labeling_no_donut.png" alt="A" width="240"/>
</div>
<div class="title">Figure 12. Bolhas sem regiões com buraco</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Por fim é feito a contagem das bolhas sem buraco. Segue o trecho do código.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">bubbles = 0;
for(int i = 0; i &lt; height; i++){
    for(int j = 0; j &lt; width; j++){
        if(image.at&lt;uchar&gt;(i, j) != 255){
            bubbles++;
            cv::floodFill(image, cv::Point(j,i), 255);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como saída final do código, para a figura <strong>bolhas.png</strong>, temos:<br/>
Total de Objetos: 21<br/>
Total de Rosquinha: 7<br/>
Total de Bolhas: 14<br/></p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_atividade_05">Atividade 05</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_etapa_01_3">Etapa 01</h3>
<div class="paragraph">
<p>Esta atividade busca realizar a equalização do histograma durante a captura de uma câmera.</p>
</div>
<details>
<summary class="title">Show Code</summary>
<div class="content">
<div class="listingblock">
<div class="title">equalize.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

void histogram_computation(cv::Mat imageInput, int *histogram){
    for(int i = 0; i &lt; 256; i++){
        histogram[i] = 0;
    }
    for(int i = 0; i &lt; imageInput.rows; i++){
        for(int j = 0; j &lt; imageInput.cols; j++){
            histogram[imageInput.at&lt;uchar&gt;(i,j)] += 1;
        }
    }
}

void histogram_equaliation(cv::Mat imageInput, cv::Mat *imageOutput){
    int histogram[256], histogram_accumulate[256];
    float alpha = 255.0/(imageInput.cols * imageInput.rows);

    histogram_computation(imageInput, histogram);
    histogram_accumulate[0] = alpha * histogram[0];
    for(int i = 1; i &lt; 256; i++){
        histogram_accumulate[i] = histogram_accumulate[i-1] + (alpha * histogram[i]);
    }

    for(int i = 0; i &lt; imageInput.rows; i++){
        for(int j = 0; j &lt; imageInput.cols; j++){
            (*imageOutput).at&lt;uchar&gt;(i,j) = histogram_accumulate[imageInput.at&lt;uchar&gt;(i,j)];
        }
    }
}

int main(int argc, char** argv){
    cv::Mat image, image_gray;
    int width, height;
    cv::VideoCapture cap;
    cv::Mat histGray, histGrayEq;
    int nbins = 256;
    float range[] = {0, 255};
    const float *histrange = { range };
    bool uniform = true;
    bool acummulate = false;
    int key;

    cap.open(0);

    if(!cap.isOpened()){
        std::cout &lt;&lt; "cameras indisponiveis";
        return -1;
    }

    cap.set(cv::CAP_PROP_FRAME_WIDTH, 640);
    cap.set(cv::CAP_PROP_FRAME_HEIGHT, 480);
    width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
    height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);

    std::cout &lt;&lt; "largura = " &lt;&lt; width &lt;&lt; std::endl;
    std::cout &lt;&lt; "altura  = " &lt;&lt; height &lt;&lt; std::endl;

    int histw = nbins, histh = nbins/2;

    cv::Mat histImgGray(histh, histw, CV_8UC1, cv::Scalar(0));
    cv::Mat histImgGrayEq(histh, histw, CV_8UC1, cv::Scalar(0));
    cv::Mat image_gray_equalization(height, width, CV_8UC1, cv::Scalar(0));

    while(1){
        cap &gt;&gt; image;

        cv::cvtColor(image, image_gray, cv::COLOR_BGR2GRAY);

        histogram_equaliation(image_gray, &amp;image_gray_equalization);

        cv::calcHist(&amp;image_gray, 1, 0, cv::Mat(), histGray, 1,
                     &amp;nbins, &amp;histrange,
                     uniform, acummulate);
        cv::calcHist(&amp;image_gray_equalization, 1, 0, cv::Mat(), histGrayEq, 1,
                     &amp;nbins, &amp;histrange,
                     uniform, acummulate);

        cv::normalize(histGray, histGray, 0, histImgGray.rows, cv::NORM_MINMAX, -1, cv::Mat());
        cv::normalize(histGrayEq, histGrayEq, 0, histImgGrayEq.rows, cv::NORM_MINMAX, -1, cv::Mat());

        histImgGray.setTo(cv::Scalar(0));
        histImgGrayEq.setTo(cv::Scalar(0));

        for(int i=0; i&lt;nbins; i++){
            cv::line(histImgGray,
                cv::Point(i, histh),
                cv::Point(i, histh-cvRound(histGray.at&lt;float&gt;(i))),
                cv::Scalar(255), 1, 8, 0);
            cv::line(histImgGrayEq,
                cv::Point(i, histh),
                cv::Point(i, histh-cvRound(histGrayEq.at&lt;float&gt;(i))),
                cv::Scalar(255), 1, 8, 0);
        }

        histImgGray.copyTo(image_gray(cv::Rect(0, 0,nbins, histh)));
        histImgGrayEq.copyTo(image_gray_equalization(cv::Rect(0, 0,nbins, histh)));

        cv::imshow("Image Normal", image_gray);
        cv::imshow("Equalizado", image_gray_equalization);

        key = cv::waitKey(30);
        if(key == 27) break;
    }
    return 0;
}</code></pre>
</div>
</div>
</div>
</details>
<div class="videoblock">
<div class="title">Video Normal/Equalizador</div>
<div class="content">
<iframe src="https://www.youtube.com/embed/TYsMKFstamg?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Comentários:</p>
</div>
<div class="paragraph">
<p>Várias declarações são feita logo nas linhas iniciais da função <strong>main</strong>, dentre elas a variável <strong>cap</strong>. <strong>cap</strong> é um objeto do tipo <strong>VideoCapture</strong> responsável por receber um fluxo de frames de uma determinado dispositivo de vídeo. Para execução desse código foi utilizado a webcam embutida no notebook e a sua inicialização é feita através do seguinte comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">cap.open(0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, é feito uma configuração no tamanhos dos frames a serem capturados pela câmera. Trecho a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">cap.set(cv::CAP_PROP_FRAME_WIDTH, 640);
cap.set(cv::CAP_PROP_FRAME_HEIGHT, 480);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As linhas de código:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">cv::Mat histImgGray(histh, histw, CV_8UC1, cv::Scalar(0));
cv::Mat histImgGrayEq(histh, histw, CV_8UC1, cv::Scalar(0));</code></pre>
</div>
</div>
<div class="paragraph">
<p>são matrizes que irão armazenar informações do histograma. Nesse trecho acima, as duas matrizes são declaradas e instanciadas, todas as posições delas são atribuidas o valor 0.</p>
</div>
<div class="paragraph">
<p>A captura de um frame do fluxo é feita por:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">cap &gt;&gt; image;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Logo em seguida, o frame capturado é convertido para uma imagem em tons de cinza, nota-se que o frame obtido inicialmente está no padrão RGB. Segue a linha responsável por essa tarefa.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">cv::cvtColor(image, image_gray, cv::COLOR_BGR2GRAY);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida temos a equalização do histograma que é feita pela função <strong>histogram_equalization</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">void histogram_equaliation(cv::Mat imageInput, cv::Mat *imageOutput){
    int histogram[256], histogram_accumulate[256];
    float alpha = 255.0/(imageInput.cols * imageInput.rows);

    histogram_computation(imageInput, histogram);
    histogram_accumulate[0] = alpha * histogram[0];
    for(int i = 1; i &lt; 256; i++){
        histogram_accumulate[i] = histogram_accumulate[i-1] + (alpha * histogram[i]);
    }

    for(int i = 0; i &lt; imageInput.rows; i++){
        for(int j = 0; j &lt; imageInput.cols; j++){
            (*imageOutput).at&lt;uchar&gt;(i,j) = histogram_accumulate[imageInput.at&lt;uchar&gt;(i,j)];
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Basicamente a função acima faz o cálculo do histograma acumulado ponderando cada ponto por um fator <strong>alpha</strong>. O <strong>alpha</strong> é obtido dividindo o valor de cor máximo (255) pela quantidade de pixels da imagem. De posse do histograma aculmulado e feito o mapeamento de cada pixel da imagem no histograma aculmulado, gerando assim um novo frame equalizado.</p>
</div>
<div class="paragraph">
<p>Nas linhas seguintes são feitas: o cálculo do histograma (com a funcão <strong>calcHist</strong> do pacote do opencv), a normalização e o preechimento das matrizes que serão utilizadas para desenhar o histograma na janela de exibição.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">cv::calcHist(&amp;image_gray, 1, 0, cv::Mat(), histGray, 1,
             &amp;nbins, &amp;histrange,
             uniform, acummulate);
cv::calcHist(&amp;image_gray_equalization, 1, 0, cv::Mat(), histGrayEq, 1,
             &amp;nbins, &amp;histrange,
             uniform, acummulate);

cv::normalize(histGray, histGray, 0, histImgGray.rows, cv::NORM_MINMAX, -1, cv::Mat());
cv::normalize(histGrayEq, histGrayEq, 0, histImgGrayEq.rows, cv::NORM_MINMAX, -1, cv::Mat());

histImgGray.setTo(cv::Scalar(0));
histImgGrayEq.setTo(cv::Scalar(0));

for(int i=0; i&lt;nbins; i++){
    cv::line(histImgGray,
    cv::Point(i, histh),
    cv::Point(i, histh-cvRound(histGray.at&lt;float&gt;(i))),
    cv::Scalar(255), 1, 8, 0);
    cv::line(histImgGrayEq,
    cv::Point(i, histh),
    cv::Point(i, histh-cvRound(histGrayEq.at&lt;float&gt;(i))),
    cv::Scalar(255), 1, 8, 0);
}

histImgGray.copyTo(image_gray(cv::Rect(0, 0,nbins, histh)));
histImgGrayEq.copyTo(image_gray_equalization(cv::Rect(0, 0,nbins, histh)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>A exibição do fluxo de vídeo e feita por:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">cv::imshow("Image Normal", image_gray);
cv::imshow("Equalizado", image_gray_equalization);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_etapa_02_3">Etapa 02</h3>
<div class="paragraph">
<p>Nesta segunda etapa é proposto a realização de um detector de movimento. Sua implementação deu-se comparando um histograma passado com um corrente, foi usado apenas um canal de cor, nesse caso o vermelho.</p>
</div>
<div class="paragraph">
<p>O código implementado:</p>
</div>
<details>
<summary class="title">Show Code</summary>
<div class="content">
<div class="listingblock">
<div class="title">motiondetector.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

bool move_detection(cv::Mat hist_current, cv::Mat hist_old, int limiar){
    double erro = 0;

    for(int i=0; i &lt; 256; i++){
        if(hist_current.at&lt;u_int8_t&gt;(i) != 0)
            erro += abs((hist_current.at&lt;u_int8_t&gt;(i) - hist_old.at&lt;u_int8_t&gt;(i))/double(hist_current.at&lt;u_int8_t&gt;(i)));
    }
    erro = erro/256.0;
    if(erro &gt; limiar)
        return true;
    else
        return false;
}

int main(int argc, char **argv){
    cv::Mat image;
    int width, height;
    cv::VideoCapture cap;
    std::vector&lt;cv::Mat&gt; planes;
    cv::Mat histR, histR_old, histG, histB;
    int nbins = 64;
    float range[] = {0, 255};
    const float *histrange = { range };
    bool uniform = true;
    bool acummulate = false;
    int key;
    int limiar = 2.0;

    cap.open(0);

    if(!cap.isOpened()){
        std::cout &lt;&lt; "Camera indisponivel";
        return -1;
    }

    cap.set(cv::CAP_PROP_FRAME_WIDTH, 640);
    cap.set(cv::CAP_PROP_FRAME_HEIGHT, 480);
    width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
    height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);

    std::cout &lt;&lt; "largura = " &lt;&lt; width &lt;&lt; std::endl;
    std::cout &lt;&lt; "altura  = " &lt;&lt; height &lt;&lt; std::endl;

    int histw = nbins, histh = nbins/2;
    cv::Mat histImgR(histh, histw, CV_8UC3, cv::Scalar(0,0,0));
    cv::Mat histImgG(histh, histw, CV_8UC3, cv::Scalar(0,0,0));
    cv::Mat histImgB(histh, histw, CV_8UC3, cv::Scalar(0,0,0));

    while (1){
        cap &gt;&gt; image;
        cv::split (image, planes);
        cv::calcHist(&amp;planes[0], 1, 0, cv::Mat(), histB, 1,
                    &amp;nbins, &amp;histrange,
                    uniform, acummulate);
        cv::calcHist(&amp;planes[1], 1, 0, cv::Mat(), histG, 1,
                    &amp;nbins, &amp;histrange,
                    uniform, acummulate);
        cv::calcHist(&amp;planes[2], 1, 0, cv::Mat(), histR, 1,
                    &amp;nbins, &amp;histrange,
                    uniform, acummulate);

        cv::normalize(histR, histR, 0, histImgR.rows, cv::NORM_MINMAX, -1, cv::Mat());
        cv::normalize(histG, histG, 0, histImgG.rows, cv::NORM_MINMAX, -1, cv::Mat());
        cv::normalize(histB, histB, 0, histImgB.rows, cv::NORM_MINMAX, -1, cv::Mat());

        histImgR.setTo(cv::Scalar(0));
        histImgG.setTo(cv::Scalar(0));
        histImgB.setTo(cv::Scalar(0));

        for(int i=0; i&lt;nbins; i++){
            cv::line(histImgR,
                cv::Point(i, histh),
                cv::Point(i, histh-cvRound(histR.at&lt;float&gt;(i))),
                cv::Scalar(0, 0, 255), 1, 8, 0);
            cv::line(histImgG,
                cv::Point(i, histh),
                cv::Point(i, histh-cvRound(histG.at&lt;float&gt;(i))),
                cv::Scalar(0, 255, 0), 1, 8, 0);
            cv::line(histImgB,
                cv::Point(i, histh),
                cv::Point(i, histh-cvRound(histB.at&lt;float&gt;(i))),
                cv::Scalar(255, 0, 0), 1, 8, 0);
        }

        histImgR.copyTo(image(cv::Rect(0, 0       ,nbins, histh)));
        histImgG.copyTo(image(cv::Rect(0, histh   ,nbins, histh)));
        histImgB.copyTo(image(cv::Rect(0, 2*histh ,nbins, histh)));

        if(!histR_old.empty() &amp;&amp; move_detection(histR, histR_old, limiar)){
            cv::putText(image, "Move Detect", cv::Point2d(height/2, width/2), cv::FONT_HERSHEY_SIMPLEX, 1,cv::Scalar(0,0,255));
        }

        cv::imshow("image", image);

        histR.copyTo(histR_old);

        key = cv::waitKey(30);
        if(key == 27) break;
    }
    return 0;
}</code></pre>
</div>
</div>
</div>
</details>
<div class="videoblock">
<div class="title">Video Detector de Movimento</div>
<div class="content">
<iframe src="https://www.youtube.com/embed/x0OueLljhzE?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Comentários:</p>
</div>
<div class="paragraph">
<p>Basicamente foi adicionado uma função que compara o histograma de um frame anterior com o atual.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">bool move_detection(cv::Mat hist_current, cv::Mat hist_old, int limiar){
    double erro = 0;

    for(int i=0; i &lt; 256; i++){
        if(hist_current.at&lt;u_int8_t&gt;(i) != 0)
            erro += abs((hist_current.at&lt;u_int8_t&gt;(i) - hist_old.at&lt;u_int8_t&gt;(i))/double(hist_current.at&lt;u_int8_t&gt;(i)));
    }
    erro = erro/256.0;
    if(erro &gt; limiar)
        return true;
    else
        return false;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Essa função faz uma soma do erro entre todos os tons presente no histograma atual e antigo de forma culmulativa, e posteriormente divide pela quantidade de tons. Caso o valor desse erro esteja maior que um limiar a função retorna <strong>true</strong>, caso contrário retorna <strong>false</strong>.<br/>
A chamada da função na main é:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">if(!histR_old.empty() &amp;&amp; move_detection(histR, histR_old, limiar)){
            cv::putText(
                image,
                "Move Detect",
                cv::Point2d(height/2, width/2),
                cv::FONT_HERSHEY_SIMPLEX,
                1,
                cv::Scalar(0,0,255)
            );
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sendo assim, caso seja detectado o movimento na cena é desenhado o texto <strong>Move Detect</strong> na tela.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_atividade_06">Atividade 06</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nessa atividade deseja-se que seja adicionado a um código já existente, uma nova funcionalidade. Nesse caso o cálculo do laplaciano do gaussiano.</p>
</div>
<details>
<summary class="title">Show Code</summary>
<div class="content">
<div class="listingblock">
<div class="title">laplgauss.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

void printmask(cv::Mat &amp;m) {
    for (int i = 0; i &lt; m.size().height; i++) {
        for (int j = 0; j &lt; m.size().width; j++) {
            std::cout &lt;&lt; m.at&lt;float&gt;(i, j) &lt;&lt; ",";
        }
        std::cout &lt;&lt; "\n";
    }
}

int main(int, char **) {
    cv::VideoCapture cap;  // open the default camera
    float media[] = {0.1111, 0.1111, 0.1111,
                     0.1111, 0.1111, 0.1111,
                     0.1111, 0.1111, 0.1111};
    float gauss[] = {0.0625, 0.1250, 0.0625,
                     0.1250, 0.2500, 0.1250,
                     0.0625, 0.1250, 0.0625};
    float horizontal[] = {-1, 0, 1,
                          -2, 0, 2,
                          -1, 0, 1};
    float vertical[] = {-1,-2,-1,
                         0, 0, 0,
                         1, 2, 1};
    float laplacian[] = { 0,-1, 0,
                         -1, 4,-1,
                          0,-1, 0};
    float boost[] = { 0, -1, 0,
                     -1,5.2,-1,
                      0, -1, 0};

    cv::Mat frame, framegray, frame32f, frameFiltered;
    std::vector&lt;cv::Mat&gt; mask = {cv::Mat(3, 3, CV_32F), cv::Mat(3,3,CV_32F)};
    cv::Mat result;
    double width, height;
    int absolut;
    char key;
    int qtd_filter = 1;
    std::string nameFilter[2];

    cap.open(0);

    if (!cap.isOpened()){
        std::cout &lt;&lt; "Camera indisponivel" &lt;&lt; std::endl;
        return -1;
    }  // check if we succeeded

    cap.set(cv::CAP_PROP_FRAME_WIDTH, 640);
    cap.set(cv::CAP_PROP_FRAME_HEIGHT, 480);
    width = cap.get(cv::CAP_PROP_FRAME_WIDTH);
    height = cap.get(cv::CAP_PROP_FRAME_HEIGHT);
    std::cout &lt;&lt; "largura=" &lt;&lt; width &lt;&lt; "\n";
    std::cout &lt;&lt; "altura =" &lt;&lt; height &lt;&lt; "\n";

    std::cout &lt;&lt; "fps    =" &lt;&lt; cap.get(cv::CAP_PROP_FPS) &lt;&lt; "\n";
    std::cout &lt;&lt; "format =" &lt;&lt; cap.get(cv::CAP_PROP_FORMAT) &lt;&lt; "\n";

    cv::namedWindow("filtroespacial", cv::WINDOW_NORMAL);
    cv::namedWindow("original", cv::WINDOW_NORMAL);

    mask[0] = cv::Mat(3, 3, CV_32F, media);
    nameFilter[0] = "filtroespacial";

    absolut = 1;  // calcs abs of the image

    for (;;) {
        cap &gt;&gt; frame;  // get a new frame from camera
        cv::cvtColor(frame, framegray, cv::COLOR_BGR2GRAY);
        cv::flip(framegray, framegray, 1);
        cv::imshow("original", framegray);
        framegray.convertTo(frame32f, CV_32F);

        for(int i = 0; i &lt; qtd_filter; i++){
            cv::filter2D(frame32f, frameFiltered, frame32f.depth(), mask[i], cv::Point(1, 1), 0);


            if (absolut) {
                frameFiltered = cv::abs(frameFiltered);
            }

            frameFiltered.convertTo(result, CV_8U);

            cv::imshow(nameFilter[i], result);

            frameFiltered.copyTo(frame32f);
        }
        key = (char)cv::waitKey(10);
        if (key == 27) break;  // esc pressed!
        switch (key) {
            case 'a':
                absolut = !absolut;
                break;
            case 'm':
                mask[0] = cv::Mat(3, 3, CV_32F, media);
                printmask(mask[0]);
                nameFilter[0] = "filtroespacial";
                qtd_filter = 1;
                break;
            case 'g':
                mask[0] = cv::Mat(3, 3, CV_32F, gauss);
                printmask(mask[0]);
                nameFilter[0] = "filtroespacial";
                qtd_filter = 1;
                break;
            case 'h':
                mask[0] = cv::Mat(3, 3, CV_32F, horizontal);
                printmask(mask[0]);
                nameFilter[0] = "filtroespacial";
                qtd_filter = 1;
                break;
            case 'v':
                mask[0] = cv::Mat(3, 3, CV_32F, vertical);
                printmask(mask[0]);
                nameFilter[0] = "filtroespacial";
                qtd_filter = 1;
                break;
            case 'l':
                mask[0] = cv::Mat(3, 3, CV_32F, laplacian);
                printmask(mask[0]);
                nameFilter[0] = "filtroespacial";
                qtd_filter = 1;
                break;
            case 'b':
                mask[0] = cv::Mat(3, 3, CV_32F, boost);
                nameFilter[0] = "filtroespacial";
                qtd_filter = 1;
                break;
            case 'e':
                mask[0] = cv::Mat(3, 3, CV_32F, laplacian);
                mask[1] = cv::Mat(3, 3, CV_32F, gauss);
                nameFilter[0] = "filtroespacial";
                nameFilter[1] = "Laplacian - Gauss";
                qtd_filter = 2;
                break;
            default:
                break;
        }

    }
    return 0;
}</code></pre>
</div>
</div>
</div>
</details>
<div class="videoblock">
<div class="title">Video Laplacian - Gauss</div>
<div class="content">
<iframe src="https://www.youtube.com/embed/tcLRgt_L_Ak?rel=0" frameborder="0" allowfullscreen="allowfullscreen"></iframe>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Comentários:</p>
</div>
<div class="paragraph">
<p>Basicamento, foi adicionado ao código um vetor de máscara.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::vector&lt;cv::Mat&gt; mask = {cv::Mat(3, 3, CV_32F), cv::Mat(3,3,CV_32F)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando, durante a execução do código, for precionado a tecla "<strong>e</strong>" seria aplicado dois filtros, o lapalacian e o gauss. Esse trecho de código é responsável por essa funcionalidas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">case 'e':
    mask[0] = cv::Mat(3, 3, CV_32F, laplacian);
    mask[1] = cv::Mat(3, 3, CV_32F, gauss);
    nameFilter[0] = "filtroespacial";
    nameFilter[1] = "Laplacian - Gauss";
    qtd_filter = 2;
    break;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um loop <strong>for</strong> é responsável por aplicar os dois filtros no frame.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">for(int i = 0; i &lt; qtd_filter; i++){
    cv::filter2D(frame32f, frameFiltered, frame32f.depth(), mask[i], cv::Point(1, 1), 0);
    if (absolut) {
        frameFiltered = cv::abs(frameFiltered);
    }
    frameFiltered.convertTo(result, CV_8U);
    cv::imshow(nameFilter[i], result);
    frameFiltered.copyTo(frame32f);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ao observar o filtro laplaciano puro e posteriormente com aplicação do filtro de gauss, podemos notar uma redução do ruido. Note, a imagem abaixo não está com valores absolutos para os pixels.</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/laplgauss_noabs.png" alt="A" width="640"/>
</div>
<div class="title">Figure 13. Laplacian vs laplacian-Gauss (no absolut)</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Ao habilitar os valores absolutos, temos uma melhora mais significativa com a redução melhor do ruído.</p>
</div>
<div class="openblock float-group">
<div class="content">
<div class="imageblock left">
<div class="content">
<img src="images/laplgauss_abs.png" alt="A" width="640"/>
</div>
<div class="title">Figure 14. Laplacian vs laplacian-Gauss (absolut)</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>